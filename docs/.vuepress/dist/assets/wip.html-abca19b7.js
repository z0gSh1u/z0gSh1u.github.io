import{_ as a,M as l,p as s,q as h,R as t,t as e,N as n,a1 as r}from"./framework-c7158ea4.js";const i={},d={id:"gomon",tabindex:"-1"},c=t("a",{class:"header-anchor",href:"#gomon","aria-hidden":"true"},"#",-1),_={href:"https://github.com/z0gSh1u/gomon",target:"_blank",rel:"noopener noreferrer"},u=r("<table><thead><tr><th>状态</th><th>语言/技术栈</th></tr></thead><tbody><tr><td><strong>🚧</strong> 施工中</td><td>Vue 3 + Go (Gin) + MongoDB</td></tr></tbody></table><p>我计划实现一个可快速插拔部署的自托管评论系统。</p><ul><li>用户在前端部分引入 Vue 组件，对于每篇被评论文章注入一个配置项 props 即可工作</li><li>后端采用 Gin 提供 API 接口，采用 MongoDB 进行持久化，支持 Docker 容器化部署</li></ul>",3),p={id:"sxone",tabindex:"-1"},g=t("a",{class:"header-anchor",href:"#sxone","aria-hidden":"true"},"#",-1),b={href:"https://github.com/z0gSh1u/sxone",target:"_blank",rel:"noopener noreferrer"},m=r("<table><thead><tr><th>状态</th><th>语言/技术栈</th></tr></thead><tbody><tr><td><strong>🚧</strong> 施工中</td><td>Vue 3 + Go (Gin)</td></tr></tbody></table><p>我注意到</p><ul><li>如今，游戏的平台越来越多，但许多单机游戏玩过一次后便丢在一边，没有留下任何痕迹</li><li>动漫番剧大家也看得越来越多，但看完之后总想找个地方写点总结，不然好像没有看过</li><li>好像读书也有类似的情况…</li></ul><p>所以，我希望构建一个平台，它能够</p><ul><li>给大家一个写游戏评测、番剧观后感的集合处</li><li>有办法读取各种游戏平台的游戏时间等参数</li><li>支持外链到第三方创作平台（如知乎、豆瓣、百家号），构建创作私域矩阵，助力盈利</li><li>Markdown 写作</li><li>Docker 部署</li></ul>",5),f={id:"gamo",tabindex:"-1"},k=t("a",{class:"header-anchor",href:"#gamo","aria-hidden":"true"},"#",-1),x={href:"https://github.com/z0gSh1u/gamo",target:"_blank",rel:"noopener noreferrer"},y=r("<table><thead><tr><th>状态</th><th>语言/技术栈</th></tr></thead><tbody><tr><td><strong>🚧</strong> 施工中</td><td>C# + WebSocket + Vue 3</td></tr></tbody></table><p>在进行游戏时，常常希望可以监控 CPU、显卡、内存等硬件的使用情况。然而，退出到任务管理器太过麻烦，Afterburner 等工具又对画面有侵入性。</p><p>因此，我希望构建一个监视器，它在电脑端使用 C# 采集相关数据，使用 Websocket 推送到手机端，恰当显示。这样，手机便成为了一个外置的性能监视器。</p><p>选型使用 C# 的原因是它对 Windows API 的可操作性更好、更方便。</p>",4),S={id:"tinydragon",tabindex:"-1"},w=t("a",{class:"header-anchor",href:"#tinydragon","aria-hidden":"true"},"#",-1),A={href:"https://github.com/z0gSh1u/tinydragon",target:"_blank",rel:"noopener noreferrer"},N=t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"状态"),t("th",null,"语言/技术栈")])]),t("tbody",null,[t("tr",null,[t("td",null,[t("strong",null,"🚧"),e(" 施工中")]),t("td",null,"TypeScript")])])],-1),T={href:"https://github.com/seu-cs-class2/minisys-minicc-ts",target:"_blank",rel:"noopener noreferrer"},V={href:"https://www.antlr.org/",target:"_blank",rel:"noopener noreferrer"},W={id:"kramup",tabindex:"-1"},C=t("a",{class:"header-anchor",href:"#kramup","aria-hidden":"true"},"#",-1),G={href:"https://github.com/z0gSh1u/kramup",target:"_blank",rel:"noopener noreferrer"},M=t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"状态"),t("th",null,"语言/技术栈")])]),t("tbody",null,[t("tr",null,[t("td",null,[t("strong",null,"🚧"),e(" 施工中")]),t("td",null,"C# + WPF + ANTLR")])])],-1),I=t("p",null,"本项目计划制作一个非 WYSIWYG 的 Markdown 编辑器。使用 ANTLR 对 Markdown 文件进行词法、语法分析，使用 C# visit AST 结点转换为 HTML，使用 WPF（甚至考虑 UWP）构建 GUI。",-1);function L(P,z){const o=l("ExternalLinkIcon");return s(),h("div",null,[t("h2",d,[c,e(),t("a",_,[e("gomon"),n(o)])]),u,t("h2",p,[g,e(),t("a",b,[e("sxone"),n(o)])]),m,t("h2",f,[k,e(),t("a",x,[e("gamo"),n(o)])]),y,t("h2",S,[w,e(),t("a",A,[e("tinydragon"),n(o)])]),N,t("p",null,[e("在已完成的 "),t("a",T,[e("minisys-minicc-ts"),n(o)]),e(" 项目中，如果将它的代码到编译部分进一步抽象，我们可以得到一个从词法描述文件+语法描述文件到词法分析器、语法分析器、AST 生成器的工具（类似于 "),t("a",V,[e("ANTLR"),n(o)]),e("）。这使得我们可以进行通用的词法、语法分析与处理。")]),t("h2",W,[C,e(),t("a",G,[e("kramup"),n(o)])]),M,I])}const v=a(i,[["render",L],["__file","wip.html.vue"]]);export{v as default};
